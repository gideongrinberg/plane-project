---
title: UAV Design
author: Gideon Grinberg
date: July 25, 2025
jupyter: uav_design
format:
    html:
        code-fold: true
        results: 'hide'
        
---

## Introduction

This document outlines the design of the UAV. The design was optimized using [`AeroSandbox` by Peter Sharpe](https://github.com/peterdsharpe/AeroSandbox), and the code used to generate this document is available in the Github repo. The code is heavily based on Peter's Feather glider design tool.

```{python}
#| echo: false
import pathlib
import contextlib, io
import aerosandbox as asb
import aerosandbox.numpy as np
import aerosandbox.tools.pretty_plots as p
import matplotlib.pyplot as plt
%matplotlib inline

import warnings
warnings.filterwarnings("ignore")
# Optimization setup and variables
opti = asb.Opti()

battery_energy_Wh = 30  # fixed
battery_energy_J = battery_energy_Wh * 3600  # 108 kJ
design_mass_TOGW = 0.700  # kg

velocity = opti.variable(init_guess=15, lower_bound=8, upper_bound=25)  # m/s
alpha_deg = opti.variable(init_guess=4, lower_bound=-5, upper_bound=10)  # deg
op_point = asb.OperatingPoint(velocity=velocity, alpha=alpha_deg)

# Geometry
# Wing
span = 1.50  # m  (fixed)
root_chord = opti.variable(init_guess=0.24, lower_bound=0.15, upper_bound=0.30)
taper_ratio = 0.5
tip_chord = root_chord * taper_ratio
sweep_LE = 0  # straight wing

airfoil_wing = asb.Airfoil(name="sd7037")
half_span = span / 2
wing = asb.Wing(
    name="Main Wing",
    symmetric=True,
    xsecs=[
        # Root section positioned at pod's widest point (~x=0.02 m)
        asb.WingXSec(
            xyz_le=[0.02, 0, 0],  # Moved wing rearward to pod max radius
            chord=root_chord,
            airfoil=airfoil_wing
        ),
        asb.WingXSec(
            xyz_le=[0.02 + sweep_LE, half_span, 0],
            chord=tip_chord,
            airfoil=airfoil_wing
        ),
    ],
)

# vtail
tail_arm = opti.variable(
    init_guess=0.60, lower_bound=0.45, upper_bound=1
)
v_dihedral_deg = 25

airfoil_tail = asb.Airfoil(name="naca0008")
S_h_proj = 0.042
chord_tail_root = 0.10
taper_ratio_tail = 0.5  # From tip/root chord ratio
avg_chord_tail = chord_tail_root * (1 + taper_ratio_tail) / 2
span_tail_half = S_h_proj / (2 * avg_chord_tail * np.cos(np.radians(v_dihedral_deg)))

def vrot(xyz):
    R = np.rotation_matrix_3D(angle=np.radians(v_dihedral_deg), axis="X")
    return R @ np.array(xyz)

v_tail = asb.Wing(
    name="V-Tail",
    symmetric=True,
    xsecs=[
        asb.WingXSec(
            xyz_le=vrot([tail_arm, 0, 0]), chord=chord_tail_root, airfoil=airfoil_tail
        ),
        asb.WingXSec(
            xyz_le=vrot([tail_arm, span_tail_half, 0]),
            chord=chord_tail_root * 0.5,
            airfoil=airfoil_tail,
        ),
    ],
)

# Fuselage design
pod_radius = 0.03  # 60 mm max diameter
boom_radius = 0.007  # 14 mm dia carbon tube

# Optimize fuselage nose cone
nose_radius = opti.variable(init_guess=0.03, lower_bound=0.02, upper_bound=0.05)
mid_radius  = opti.variable(init_guess=0.03, lower_bound=0.02, upper_bound=0.05)
aft_radius  = opti.variable(init_guess=0.015, lower_bound=0.01, upper_bound=0.03)
fuselage_pod = asb.Fuselage(
    xsecs = [
        asb.FuselageXSec(xyz_c=[-0.22,0,0], radius=0.0),
        asb.FuselageXSec(xyz_c=[-0.20,0,0], radius=nose_radius),
        asb.FuselageXSec(xyz_c=[ 0.02,0,0], radius=mid_radius),
        asb.FuselageXSec(xyz_c=[ 0.07,0,0], radius=aft_radius),
    ]
)

min_internal_vol = 0.0005 # ~30 cubic inches
opti.subject_to(fuselage_pod.volume() >= min_internal_vol)

fuselage_boom = asb.Fuselage(
    name="Tail Boom",
    xsecs=[
        asb.FuselageXSec(xyz_c=[0.07,     0, 0], radius=boom_radius),
        asb.FuselageXSec(xyz_c=[tail_arm, 0, 0], radius=boom_radius),
    ],
)

airplane = asb.Airplane(
    name="700 g Endurance UAV", wings=[wing, v_tail], fuselages=[fuselage_pod, fuselage_boom]
)

# Mass properties
mp_struct = asb.mass_properties_from_radius_of_gyration(
    mass=0.200, x_cg=0.05
)
mp_power = asb.mass_properties_from_radius_of_gyration(
    mass=0.055, x_cg=-0.05
)
mp_batt = asb.mass_properties_from_radius_of_gyration(
    mass=0.280, x_cg=-0.02
)
mp_elec = asb.mass_properties_from_radius_of_gyration(
    mass=0.045, x_cg=0.00
)
mp_tail = asb.mass_properties_from_radius_of_gyration(
    mass=0.095, x_cg=tail_arm
)
mp_glue = (mp_struct + mp_tail) * 0.08

mass_tot = mp_struct + mp_power + mp_batt + mp_elec + mp_tail + mp_glue
W = design_mass_TOGW * 9.81  # N (fixed)

# Aero analysis
aero = asb.AeroBuildup(
    airplane=airplane, op_point=op_point, xyz_ref=mass_tot.xyz_cg
).run_with_stability_derivatives(
    alpha=True,
    beta=False,
    p=False,
    q=False,
    r=False
)

# Constraints
opti.subject_to(
    [
        aero["L"] >= W,
        aero["Cm"] == 0,
    ]
)

static_margin = (aero["x_np"] - mass_tot.x_cg) / wing.mean_aerodynamic_chord()
opti.subject_to(static_margin >= 0.10)

opti.subject_to(
    [
        tip_chord >= 0.06,
        tail_arm <= 0.75,
    ]
)

prop_efficiency_est = 0.67
power_required = aero["D"] * velocity / prop_efficiency_est
opti.minimize(power_required)

with contextlib.redirect_stdout(io.StringIO()):
    try:
        sol = opti.solve()
    except RuntimeError:
        sol = opti.debug
        
airplane_sol = sol(airplane)
s = lambda x: sol.value(x)
```

## Three-View Plan

```{python}
airplane_sol.draw_three_view(show=False, style="wireframe")
p.show_plot(tight_layout=False)
```

## Weight Budget
```{python}
mass_components = {
    "Structure": s(mp_struct.mass),
    "Motor + Mount": s(mp_power.mass),
    "Battery": s(mp_batt.mass),
    "Electronics": s(mp_elec.mass),
    "Tail \\& Boom": s(mp_tail.mass),
}

mp_glue = sum(mass_components.values()) * 0.08
mass_components["Glue"] = mp_glue

labels = list(mass_components.keys())
values = [v*1000 for v in list(mass_components.values())] # convert to g

def make_autopct(values, suffix="g"):
    def autopct(pct):
        total = sum(values)
        val = int(round(pct * total / 100.0))
        return f"{val}{suffix}"
    return autopct

plt.figure()
plt.pie(values, labels=labels, autopct=make_autopct(values, "g"))
plt.show()
```

## Flight Characteristics

### Lift vs. Drag
```{python}
alphas = np.linspace(-5, 15, 30)
CLs = []
CDs = []

velocity_sol = s(op_point.velocity)
for alpha in alphas:
    op = asb.OperatingPoint(
        velocity=velocity_sol,
        alpha=alpha
    )
    aero = asb.AeroBuildup(
        airplane=airplane_sol,
        op_point=op
    ).run()
    CLs.append(aero["CL"])
    CDs.append(aero["CD"])

plt.figure()
plt.plot(CDs, CLs, marker="o")
plt.xlabel("CD")
plt.ylabel("CL")
plt.title("Lift vs. Drag")
plt.show()
```

### L/D vs. Airspeed (Best Glide)
```{python}
speeds = np.linspace(0, 25, 50)
LDs = []

for v in speeds:
    op = op_point.copy()
    op.velocity = v
    aero = asb.AeroBuildup(airplane=airplane_sol, op_point=sol(op)).run()
    LDs.append(aero["L"] / aero["D"])

plt.figure()
plt.plot(speeds, LDs)
plt.xlabel("Airspeed [m/s]")
plt.ylabel("L/D")
plt.title("L/D vs. Airspeed (Best Glide)")
plt.show()

```

### Sink Rate vs. Airspeed

```{python}
speeds = np.linspace(0, 25, 50)
sink_rates = []
mass_tot_kg = s(mass_tot.mass)

for v in speeds:
    op = asb.OperatingPoint(
        velocity=v,
        alpha=s(alpha_deg)
    )
    aero = asb.AeroBuildup(airplane=airplane_sol, op_point=op).run()
    power_loss = aero["D"] * v
    sink = power_loss / (mass_tot_kg * 9.81)
    sink_rates.append(sink)

plt.figure()
plt.plot(speeds, sink_rates)
plt.xlabel("Airspeed [m/s]")
plt.ylabel("Sink Rate [m/s]")
plt.title("Sink Rate vs. Airspeed")
plt.grid(True)
plt.show()
```

### Trim Curve

```{python}
alphas = np.linspace(-2, 10, 15)
cms = []

for alpha in alphas:
    op = asb.OperatingPoint(
        velocity=s(op_point.velocity),
        alpha=alpha
    )

    aero = asb.AeroBuildup(
        airplane=airplane_sol,
        op_point=op,
        xyz_ref=s(mass_tot.xyz_cg)
    ).run_with_stability_derivatives(alpha=True)
    cms.append(aero["Cm"])

plt.figure()
plt.plot(alphas, cms)
plt.axhline(0, color="black", linestyle="--")
plt.xlabel("Angle of Attack [deg]")
plt.ylabel("Pitching Moment Coefficient (Cm)")
plt.title("Trim Curve: Cm vs Alpha")
plt.grid(True)
plt.show()

print(f"Î± {" " * 5} Cm")
for a, c in zip(alphas, cms):
    print(f"{a:0.2f} {" " * 5} {c[0]:0.5f}")
```